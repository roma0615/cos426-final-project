{
  "version": 3,
  "sources": ["../../node_modules/three-to-cannon/lib/ConvexHull.js", "../../node_modules/three-to-cannon/src/utils.ts", "../../node_modules/three-to-cannon/src/index.ts"],
  "sourcesContent": ["import {\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar ConvexHull = ( function () {\n\n\tvar Visible = 0;\n\tvar Deleted = 1;\n\n\tvar v1 = new Vector3();\n\n\tfunction ConvexHull() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\tObject.assign( ConvexHull.prototype, {\n\n\t\ttoJSON: function () {\n\t\t\t// Original ('src') indices do not include interior vertices,\n\t\t\t// but 'this.vertices' (the list they index) does. Output ('dst')\n\t\t\t// arrays have interior vertices omitted.\n\n\t\t\tconst srcIndices = this.faces.map((f) => f.toArray());\n\t\t\tconst uniqueSrcIndices = Array.from(new Set(srcIndices.flat())).sort();\n\n\t\t\t// Output vertex positions, omitting interior vertices.\n\t\t\tconst dstPositions = [];\n\t\t\tfor (let i = 0; i < uniqueSrcIndices.length; i++) {\n\t\t\t\tdstPositions.push(\n\t\t\t\t\tthis.vertices[uniqueSrcIndices[i]].point.x,\n\t\t\t\t\tthis.vertices[uniqueSrcIndices[i]].point.y,\n\t\t\t\t\tthis.vertices[uniqueSrcIndices[i]].point.z,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Mapping from 'src' (this.vertices) to 'dst' (dstPositions) indices.\n\t\t\tconst srcToDstIndexMap = new Map();\n\t\t\tfor (let i = 0; i < uniqueSrcIndices.length; i++) {\n\t\t\t\tsrcToDstIndexMap.set(uniqueSrcIndices[i], i);\n\t\t\t}\n\n\t\t\t// Output triangles, as indices on dstPositions.\n\t\t\tconst dstIndices = [];\n\t\t\tfor (let i = 0; i < srcIndices.length; i++) {\n\t\t\t\tdstIndices.push([\n\t\t\t\t\tsrcToDstIndexMap.get(srcIndices[i][0]),\n\t\t\t\t\tsrcToDstIndexMap.get(srcIndices[i][1]),\n\t\t\t\t\tsrcToDstIndexMap.get(srcIndices[i][2]),\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\treturn [dstPositions, dstIndices];\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tif ( Array.isArray( points ) !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.ConvexHull: Points parameter is not an array.' );\n\n\t\t\t}\n\n\t\t\tif ( points.length < 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.ConvexHull: The algorithm needs at least four points.' );\n\n\t\t\t}\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ], i ) );\n\n\t\t\t}\n\n\t\t\tthis.compute();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\tvar points = [];\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar i, l, point;\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry === undefined ) return;\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tgeometry = geometry.toBufferGeometry\n\t\t\t\t\t\t? geometry.toBufferGeometry()\n\t\t\t\t\t\t: new BufferGeometry().fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tpoint = new Vector3();\n\n\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.setFromPoints( points );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar faces = this.faces;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectRay: function ( ray, target ) {\n\n\t\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n\n\t\t\tvar faces = this.faces;\n\n\t\t\tvar tNear = - Infinity;\n\t\t\tvar tFar = Infinity;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// interpret faces as planes for the further computation\n\n\t\t\t\tvar vN = face.distanceToPoint( ray.origin );\n\t\t\t\tvar vD = face.normal.dot( ray.direction );\n\n\t\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t\t// compute the distance from the ray’s origin to the intersection with the plane\n\n\t\t\t\tvar t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t\t// lies \"behind\" the origin\n\n\t\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// front-face\n\n\t\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// evaluate intersection point\n\n\t\t\t// always try tNear first since its the closer intersection point\n\n\t\t\tif ( tNear !== - Infinity ) {\n\n\t\t\t\tray.at( tNear, target );\n\n\t\t\t} else {\n\n\t\t\t\tray.at( tFar, target );\n\n\t\t\t}\n\n\t\t\treturn target;\n\n\t\t},\n\n\t\tintersectsRay: function ( ray ) {\n\n\t\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.faces = [];\n\t\t\tthis.vertices = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\t\taddVertexToFace: function ( vertex, face ) {\n\n\t\t\tvertex.face = face;\n\n\t\t\tif ( face.outside === null ) {\n\n\t\t\t\tthis.assigned.append( vertex );\n\n\t\t\t} else {\n\n\t\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t\t}\n\n\t\t\tface.outside = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\t\tremoveVertexFromFace: function ( vertex, face ) {\n\n\t\t\tif ( vertex === face.outside ) {\n\n\t\t\t\t// fix face.outside link\n\n\t\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\t\tface.outside = vertex.next;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\t\tface.outside = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.assigned.remove( vertex );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\t\tremoveAllVerticesFromFace: function ( face ) {\n\n\t\t\tif ( face.outside !== null ) {\n\n\t\t\t\t// reference to the first and last vertex of this face\n\n\t\t\t\tvar start = face.outside;\n\t\t\t\tvar end = face.outside;\n\n\t\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\t\tend = end.next;\n\n\t\t\t\t}\n\n\t\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t\t// fix references\n\n\t\t\t\tstart.prev = end.next = null;\n\t\t\t\tface.outside = null;\n\n\t\t\t\treturn start;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Removes all the visible vertices that 'face' is able to see\n\n\t\tdeleteFaceVertices: function ( face, absorbingFace ) {\n\n\t\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\t\tif ( faceVertices !== undefined ) {\n\n\t\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\t\tvar vertex = faceVertices;\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t\t} while ( vertex !== null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\t\tresolveUnassignedPoints: function ( newFaces ) {\n\n\t\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\t\tvar vertex = this.unassigned.first();\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\tvar maxDistance = this.tolerance;\n\n\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\t\tvar face = newFaces[ i ];\n\n\t\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Computes the extremes of a simplex which will be the initial hull\n\n\t\tcomputeExtremes: function () {\n\n\t\t\tvar min = new Vector3();\n\t\t\tvar max = new Vector3();\n\n\t\t\tvar minVertices = [];\n\t\t\tvar maxVertices = [];\n\n\t\t\tvar i, l, j;\n\n\t\t\t// initially assume that the first vertex is the min/max\n\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t\t}\n\n\t\t\tmin.copy( this.vertices[ 0 ].point );\n\t\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t\t// compute the min/max vertex on all six directions\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvar point = vertex.point;\n\n\t\t\t\t// update the min coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the max coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t\t);\n\n\t\t\treturn { min: minVertices, max: maxVertices };\n\n\t\t},\n\n\t\t// Computes the initial simplex assigning to its faces all the points\n\t\t// that are candidates to form part of the hull\n\n\t\tcomputeInitialHull: function () {\n\n\t\t\tvar line3, plane, closestPoint;\n\n\t\t\treturn function computeInitialHull() {\n\n\t\t\t\tif ( line3 === undefined ) {\n\n\t\t\t\t\tline3 = new Line3();\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar vertex, vertices = this.vertices;\n\t\t\t\tvar extremes = this.computeExtremes();\n\t\t\t\tvar min = extremes.min;\n\t\t\t\tvar max = extremes.max;\n\n\t\t\t\tvar v0, v1, v2, v3;\n\t\t\t\tvar i, l, j;\n\n\t\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t\t\t// (max.x - min.x)\n\t\t\t\t// (max.y - min.y)\n\t\t\t\t// (max.z - min.z)\n\n\t\t\t\tvar distance, maxDistance = 0;\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tindex = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tv0 = min[ index ];\n\t\t\t\tv1 = max[ index ];\n\n\t\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\t\t\tmaxDistance = 0;\n\t\t\t\tline3.set( v0.point, v1.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\n\n\t\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\t\t\tmaxDistance = - 1;\n\t\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar faces = [];\n\n\t\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// the initial hull is the tetrahedron\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\t// Removes inactive faces\n\n\t\treindexFaces: function () {\n\n\t\t\tvar activeFaces = [];\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\tactiveFaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.faces = activeFaces;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Finds the next vertex to create faces with the current hull\n\n\t\tnextVertexToAdd: function () {\n\n\t\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\t\tvar eyeVertex, maxDistance = 0;\n\n\t\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\t\tvar eyeFace = this.assigned.first().face;\n\t\t\t\tvar vertex = eyeFace.outside;\n\n\t\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = vertex.next;\n\n\t\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\t\treturn eyeVertex;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t\t// For an edge to be part of the horizon it must join a face that can see\n\t\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\t\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\n\n\t\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\t\tthis.deleteFaceVertices( face );\n\n\t\t\tface.mark = Deleted;\n\n\t\t\tvar edge;\n\n\t\t\tif ( crossEdge === null ) {\n\n\t\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\t\tedge = crossEdge.next;\n\n\t\t\t}\n\n\t\t\tdo {\n\n\t\t\t\tvar twinEdge = edge.twin;\n\t\t\t\tvar oppositeFace = twinEdge.face;\n\n\t\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== crossEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\t\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\n\n\t\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\t\tthis.faces.push( face );\n\n\t\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t\t},\n\n\t\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t\t//  horizon opposite face and the face on the left/right\n\n\t\taddNewFaces: function ( eyeVertex, horizon ) {\n\n\t\t\tthis.newFaces = [];\n\n\t\t\tvar firstSideEdge = null;\n\t\t\tvar previousSideEdge = null;\n\n\t\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\n\n\t\t\t\tvar horizonEdge = horizon[ i ];\n\n\t\t\t\t// returns the right side edge\n\n\t\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t\t}\n\n\t\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t\t}\n\n\t\t\t// perform final join of new faces\n\n\t\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the hull\n\n\t\taddVertexToHull: function ( eyeVertex ) {\n\n\t\t\tvar horizon = [];\n\n\t\t\tthis.unassigned.clear();\n\n\t\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\t\treturn\tthis;\n\n\t\t},\n\n\t\tcleanup: function () {\n\n\t\t\tthis.assigned.clear();\n\t\t\tthis.unassigned.clear();\n\t\t\tthis.newFaces = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar vertex;\n\n\t\t\tthis.computeInitialHull();\n\n\t\t\t// add all available vertices gradually to the hull\n\n\t\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\t\tthis.addVertexToHull( vertex );\n\n\t\t\t}\n\n\t\t\tthis.reindexFaces();\n\n\t\t\tthis.cleanup();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tfunction Face() {\n\n\t\tthis.normal = new Vector3();\n\t\tthis.midpoint = new Vector3();\n\t\tthis.area = 0;\n\n\t\tthis.constant = 0; // signed distance from face to the origin\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\t\tthis.edge = null;\n\n\t}\n\n\tObject.assign( Face, {\n\n\t\tcreate: function ( a, b, c ) {\n\n\t\t\tvar face = new Face();\n\n\t\t\tvar e0 = new HalfEdge( a, face );\n\t\t\tvar e1 = new HalfEdge( b, face );\n\t\t\tvar e2 = new HalfEdge( c, face );\n\n\t\t\t// join edges\n\n\t\t\te0.next = e2.prev = e1;\n\t\t\te1.next = e0.prev = e2;\n\t\t\te2.next = e1.prev = e0;\n\n\t\t\t// main half edge reference\n\n\t\t\tface.edge = e0;\n\n\t\t\treturn face.compute();\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Face.prototype, {\n\n\t\ttoArray: function () {\n\t\t\tconst indices = [];\n\t\t\tlet edge = this.edge;\n\t\t\tdo {\n\t\t\t\tindices.push(edge.head().index);\n\t\t\t\tedge = edge.next;\n\t\t\t} while (edge !== this.edge);\n\t\t\treturn indices;\n\t\t},\n\n\t\tgetEdge: function ( i ) {\n\n\t\t\tvar edge = this.edge;\n\n\t\t\twhile ( i > 0 ) {\n\n\t\t\t\tedge = edge.next;\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\twhile ( i < 0 ) {\n\n\t\t\t\tedge = edge.prev;\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn edge;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar triangle;\n\n\t\t\treturn function compute() {\n\n\t\t\t\tif ( triangle === undefined ) triangle = new Triangle();\n\n\t\t\t\tvar a = this.edge.tail();\n\t\t\t\tvar b = this.edge.head();\n\t\t\t\tvar c = this.edge.next.head();\n\n\t\t\t\ttriangle.set( a.point, b.point, c.point );\n\n\t\t\t\ttriangle.getNormal( this.normal );\n\t\t\t\ttriangle.getMidpoint( this.midpoint );\n\t\t\t\tthis.area = triangle.getArea();\n\n\t\t\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) - this.constant;\n\n\t\t}\n\n\t} );\n\n\t// Entity for a Doubly-Connected Edge List (DCEL).\n\n\tfunction HalfEdge( vertex, face ) {\n\n\t\tthis.vertex = vertex;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.twin = null;\n\t\tthis.face = face;\n\n\t}\n\n\tObject.assign( HalfEdge.prototype, {\n\n\t\thead: function () {\n\n\t\t\treturn this.vertex;\n\n\t\t},\n\n\t\ttail: function () {\n\n\t\t\treturn this.prev ? this.prev.vertex : null;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tlengthSquared: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tsetTwin: function ( edge ) {\n\n\t\t\tthis.twin = edge;\n\t\t\tedge.twin = this;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t// A vertex as a double linked list node.\n\n\tfunction VertexNode( point, index ) {\n\n\t\tthis.point = point;\n\t\t// index in the input array\n\t\tthis.index = index;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\t// the face that is able to see this vertex\n\t\tthis.face = null;\n\n\t}\n\n\t// A double linked list that contains vertex nodes.\n\n\tfunction VertexList() {\n\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\n\t}\n\n\tObject.assign( VertexList.prototype, {\n\n\t\tfirst: function () {\n\n\t\t\treturn this.head;\n\n\t\t},\n\n\t\tlast: function () {\n\n\t\t\treturn this.tail;\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.head = this.tail = null;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex before the target vertex\n\n\t\tinsertBefore: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target.prev;\n\t\t\tvertex.next = target;\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.prev = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex after the target vertex\n\n\t\tinsertAfter: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target;\n\t\t\tvertex.next = target.next;\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.next = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a vertex to the end of the linked list\n\n\t\tappend: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\t\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a chain of vertices where 'vertex' is the head.\n\n\t\tappendChain: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\n\t\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\t\twhile ( vertex.next !== null ) {\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t}\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the linked list\n\n\t\tremove: function ( vertex ) {\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex.next;\n\n\t\t\t}\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex.prev;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\t\tremoveSubList: function ( a, b ) {\n\n\t\t\tif ( a.prev === null ) {\n\n\t\t\t\tthis.head = b.next;\n\n\t\t\t} else {\n\n\t\t\t\ta.prev.next = b.next;\n\n\t\t\t}\n\n\t\t\tif ( b.next === null ) {\n\n\t\t\t\tthis.tail = a.prev;\n\n\t\t\t} else {\n\n\t\t\t\tb.next.prev = a.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\treturn this.head === null;\n\n\t\t}\n\n\t} );\n\n\treturn ConvexHull;\n\n} )();\n\nexport { ConvexHull };\n", "import { BufferAttribute, BufferGeometry, Mesh, Object3D, Quaternion, Vector3 } from 'three';\nimport type { Geometry } from 'three/examples/jsm/deprecated/Geometry';\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _q1 = new Quaternion();\n\n/**\n* Returns a single geometry for the given object. If the object is compound,\n* its geometries are automatically merged. Bake world scale into each\n* geometry, because we can't easily apply that to the cannonjs shapes later.\n*/\nexport function getGeometry (object: Object3D): BufferGeometry | null {\n\tconst meshes = getMeshes(object);\n\tif (meshes.length === 0) return null;\n\n\t// Single mesh. Return, preserving original type.\n\tif (meshes.length === 1) {\n\t\treturn normalizeGeometry(meshes[0]);\n\t}\n\n\t// Multiple meshes. Merge and return.\n\tlet mesh: Mesh | undefined;\n\tconst geometries: BufferGeometry[] = [];\n\twhile ((mesh = meshes.pop())) {\n\t\tgeometries.push(simplifyGeometry(normalizeGeometry(mesh)));\n\t}\n\n\treturn mergeBufferGeometries(geometries);\n}\n\nfunction normalizeGeometry (mesh: Mesh): BufferGeometry {\n\tlet geometry: BufferGeometry = mesh.geometry;\n\tif ((geometry as unknown as Geometry).toBufferGeometry) {\n\t\tgeometry = (geometry as unknown as Geometry).toBufferGeometry();\n\t} else {\n\t\t// Preserve original type, e.g. CylinderBufferGeometry.\n\t\tgeometry = geometry.clone();\n\t}\n\n\tmesh.updateMatrixWorld();\n\tmesh.matrixWorld.decompose(_v1, _q1, _v2);\n\tgeometry.scale(_v2.x, _v2.y, _v2.z);\n\treturn geometry;\n}\n\n/**\n * Greatly simplified version of BufferGeometryUtils.mergeBufferGeometries.\n * Because we only care about the vertex positions, and not the indices or\n * other attributes, we throw everything else away.\n */\nfunction mergeBufferGeometries (geometries: BufferGeometry[]): BufferGeometry {\n\tlet vertexCount = 0;\n\tfor (let i = 0; i < geometries.length; i++) {\n\t\tconst position = geometries[i].attributes.position;\n\t\tif (position && position.itemSize === 3) {\n\t\t\tvertexCount += position.count;\n\t\t}\n\t}\n\n\tconst positionArray = new Float32Array(vertexCount * 3);\n\n\tlet positionOffset = 0;\n\tfor (let i = 0; i < geometries.length; i++) {\n\t\tconst position = geometries[i].attributes.position;\n\t\tif (position && position.itemSize === 3) {\n\t\t\tfor (let j = 0; j < position.count; j++) {\n\t\t\t\tpositionArray[positionOffset++] = position.getX(j);\n\t\t\t\tpositionArray[positionOffset++] = position.getY(j);\n\t\t\t\tpositionArray[positionOffset++] = position.getZ(j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new BufferGeometry().setAttribute('position', new BufferAttribute(positionArray, 3));\n}\n\nexport function getVertices (geometry: BufferGeometry): Float32Array {\n\tconst position = geometry.attributes.position;\n\tconst vertices = new Float32Array(position.count * 3);\n\tfor (let i = 0; i < position.count; i++) {\n\t\tvertices[i * 3] = position.getX(i);\n\t\tvertices[i * 3 + 1] = position.getY(i);\n\t\tvertices[i * 3 + 2] = position.getZ(i);\n\t}\n\treturn vertices;\n}\n\n/**\n* Returns a flat array of THREE.Mesh instances from the given object. If\n* nested transformations are found, they are applied to child meshes\n* as mesh.userData.matrix, so that each mesh has its position/rotation/scale\n* independently of all of its parents except the top-level object.\n*/\nfunction getMeshes (object: Object3D): Mesh[] {\n\tconst meshes: Mesh[] = [];\n\tobject.traverse(function (o) {\n\t\tif ((o as Mesh).isMesh) {\n\t\t\tmeshes.push(o as Mesh);\n\t\t}\n\t});\n\treturn meshes;\n}\n\nexport function getComponent(v: Vector3, component: string): number {\n\tswitch(component) {\n\t\tcase 'x': return v.x;\n\t\tcase 'y': return v.y;\n\t\tcase 'z': return v.z;\n\t}\n\tthrow new Error(`Unexpected component ${component}`);\n}\n\n/**\n* Modified version of BufferGeometryUtils.mergeVertices, ignoring vertex\n* attributes other than position.\n*\n* @param {THREE.BufferGeometry} geometry\n* @param {number} tolerance\n* @return {THREE.BufferGeometry>}\n*/\nfunction simplifyGeometry (geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex: {[key: string]: number} = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// Next value for triangle indices.\n\tlet nextIndex = 0;\n\n\tconst newIndices = [];\n\tconst newPositions = [];\n\n\t// Convert the error tolerance to an amount of decimal places to truncate to.\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'.\n\t\tlet hash = '';\n\n\t\t// Double tilde truncates the decimal value.\n\t\thash += `${ ~ ~ ( positions.getX( index ) * shiftMultiplier ) },`;\n\t\thash += `${ ~ ~ ( positions.getY( index ) * shiftMultiplier ) },`;\n\t\thash += `${ ~ ~ ( positions.getZ( index ) * shiftMultiplier ) },`;\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index.\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\tnewPositions.push( positions.getX( index ) );\n\t\t\tnewPositions.push( positions.getY( index ) );\n\t\t\tnewPositions.push( positions.getZ( index ) );\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Construct merged BufferGeometry.\n\n\tconst positionAttribute = new BufferAttribute(\n\t\tnew Float32Array( newPositions ),\n\t\tpositions.itemSize,\n\t\tpositions.normalized\n\t);\n\n\tconst result = new BufferGeometry();\n\tresult.setAttribute( 'position', positionAttribute );\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n", "import { Box, ConvexPolyhedron, Cylinder, Quaternion as CQuaternion, Shape, Sphere, Trimesh, Vec3 } from 'cannon-es';\nimport { Box3, BufferGeometry, CylinderGeometry, MathUtils, Mesh, Object3D, SphereGeometry, Vector3 } from 'three';\nimport { ConvexHull } from '../lib/ConvexHull';\nimport { getComponent, getGeometry, getVertices } from './utils';\n\nconst PI_2 = Math.PI / 2;\n\nexport type BoxParameters = { x: number, y: number, z: number };\n\nexport type CylinderParameters = { radiusTop: number, radiusBottom: number, height: number, segments: number };\n\nexport type SphereParameters = { radius: number };\n\nexport type ConvexPolyhedronParameters = { vertices: Float32Array, faces: number[][] };\n\nexport type TrimeshParameters = { vertices: Float32Array, indices: Uint32Array };\n\ntype ShapeTypeToShapeParameters = {\n\tBox: BoxParameters,\n\tCylinder: CylinderParameters,\n\tSphere: SphereParameters,\n\tConvexPolyhedron: ConvexPolyhedronParameters,\n\tTrimesh: TrimeshParameters,\n};\n\nexport enum ShapeType {\n\tBOX = 'Box',\n\tCYLINDER = 'Cylinder',\n\tSPHERE = 'Sphere',\n\tHULL = 'ConvexPolyhedron',\n\tMESH = 'Trimesh',\n}\n\nexport interface ShapeOptions {\n\ttype?: ShapeType,\n\tcylinderAxis?: 'x' | 'y' | 'z',\n\tsphereRadius?: number,\n}\n\nexport interface ShapeParameters<T extends ShapeType = ShapeType> {\n\ttype: T,\n\tparams: ShapeTypeToShapeParameters[T],\n\toffset?: Vec3,\n\torientation?: CQuaternion,\n}\n\nexport interface ShapeResult<T extends Shape = Shape> {\n\tshape: T,\n\toffset?: Vec3,\n\torientation?: CQuaternion,\n}\n\n/**\n * Given a THREE.Object3D instance, creates parameters for a CANNON shape.\n */\nexport const getShapeParameters = function (object: Object3D, options: ShapeOptions = {}): ShapeParameters | null {\n\tlet geometry: BufferGeometry | null;\n\n\tif (options.type === ShapeType.BOX) {\n\t\treturn getBoundingBoxParameters(object);\n\t} else if (options.type === ShapeType.CYLINDER) {\n\t\treturn getBoundingCylinderParameters(object, options);\n\t} else if (options.type === ShapeType.SPHERE) {\n\t\treturn getBoundingSphereParameters(object, options);\n\t} else if (options.type === ShapeType.HULL) {\n\t\treturn getConvexPolyhedronParameters(object);\n\t} else if (options.type === ShapeType.MESH) {\n\t\tgeometry = getGeometry(object);\n\t\treturn geometry ? getTrimeshParameters(geometry) : null;\n\t} else if (options.type) {\n\t\tthrow new Error(`[CANNON.getShapeParameters] Invalid type \"${options.type}\".`);\n\t}\n\n\tgeometry = getGeometry(object);\n\tif (!geometry) return null;\n\n\tswitch (geometry.type) {\n\t\tcase 'BoxGeometry':\n\t\tcase 'BoxBufferGeometry':\n\t\t\treturn getBoxParameters(geometry);\n\t\tcase 'CylinderGeometry':\n\t\tcase 'CylinderBufferGeometry':\n\t\t\treturn getCylinderParameters(geometry as CylinderGeometry);\n\t\tcase 'PlaneGeometry':\n\t\tcase 'PlaneBufferGeometry':\n\t\t\treturn getPlaneParameters(geometry);\n\t\tcase 'SphereGeometry':\n\t\tcase 'SphereBufferGeometry':\n\t\t\treturn getSphereParameters(geometry as SphereGeometry);\n\t\tcase 'TubeGeometry':\n\t\tcase 'BufferGeometry':\n\t\t\treturn getBoundingBoxParameters(object);\n\t\tdefault:\n\t\t\tconsole.warn(\n\t\t\t\t'Unrecognized geometry: \"%s\". Using bounding box as shape.', geometry.type\n\t\t\t);\n\t\t\treturn getBoxParameters(geometry);\n\t}\n};\n\n/**\n * Given a THREE.Object3D instance, creates a corresponding CANNON shape.\n */\nexport const threeToCannon = function (object: Object3D, options: ShapeOptions = {}): ShapeResult | null {\n\tconst shapeParameters = getShapeParameters(object, options);\n\tif (!shapeParameters) {\n\t\treturn null;\n\t}\n\n\tconst { type, params, offset, orientation } = shapeParameters;\n\n\tlet shape: Shape;\n\tif (type === ShapeType.BOX) {\n\t\tshape = createBox(params as BoxParameters);\n\t} else if (type === ShapeType.CYLINDER) {\n\t\tshape = createCylinder(params as CylinderParameters);\n\t} else if (type === ShapeType.SPHERE) {\n\t\tshape = createSphere(params as SphereParameters);\n\t} else if (type === ShapeType.HULL) {\n\t\tshape = createConvexPolyhedron(params as ConvexPolyhedronParameters);\n\t} else {\n\t\tshape = createTrimesh(params as TrimeshParameters);\n\t}\n\n\treturn {\n\t\tshape,\n\t\toffset,\n\t\torientation,\n\t};\n};\n\n/******************************************************************************\n * Shape construction\n */\n\n function createBox (params: BoxParameters): Box {\n\tconst { x, y, z } = params;\n\tconst shape = new Box(new Vec3(x, y, z));\n\treturn shape;\n}\n\nfunction createCylinder (params: CylinderParameters): Cylinder {\n\tconst { radiusTop, radiusBottom, height, segments } = params;\n\n\tconst shape = new Cylinder(radiusTop, radiusBottom, height, segments);\n\n\t// Include metadata for serialization.\n\t// TODO(cleanup): Is this still necessary?\n\tshape.radiusTop = radiusBottom;\n\tshape.radiusBottom = radiusBottom;\n\tshape.height = height;\n\tshape.numSegments = segments;\n\n\treturn shape;\n}\n\nfunction createSphere (params: SphereParameters): Sphere {\n\tconst shape = new Sphere(params.radius);\n\n\treturn shape;\n}\n\nfunction createConvexPolyhedron (params: ConvexPolyhedronParameters): ConvexPolyhedron {\n\tconst { faces, vertices: verticesArray } = params;\n\n\tconst vertices: Vec3[] = [];\n\tfor (let i = 0; i < verticesArray.length; i += 3) {\n\t\tvertices.push(new Vec3(\n\t\t\tverticesArray[i],\n\t\t\tverticesArray[i + 1],\n\t\t\tverticesArray[i + 2]\n\t\t));\n\t}\n\n\tconst shape = new ConvexPolyhedron({\n\t\tfaces,\n\t\tvertices\n\t});\n\n\treturn shape;\n}\n\nfunction createTrimesh (params: TrimeshParameters): Trimesh {\n\tconst { vertices, indices } = params\n\tconst shape = new Trimesh(\n\t\tvertices as unknown as number[],\n\t\tindices as unknown as number[],\n\t);\n\n\treturn shape;\n}\n\n/******************************************************************************\n * Shape parameters\n */\n\nfunction getBoxParameters (geometry: BufferGeometry): ShapeParameters<ShapeType.BOX> | null {\n\tconst vertices = getVertices(geometry);\n\n\tif (!vertices.length) return null;\n\n\tgeometry.computeBoundingBox();\n\tconst box = geometry.boundingBox!;\n\n\treturn {\n\t\ttype: ShapeType.BOX,\n\t\tparams: {\n\t\t\tx: (box.max.x - box.min.x) / 2,\n\t\t\ty: (box.max.y - box.min.y) / 2,\n\t\t\tz: (box.max.z - box.min.z) / 2,\n\t\t},\n\t};\n}\n\n/** Bounding box needs to be computed with the entire subtree, not just geometry. */\nfunction getBoundingBoxParameters (object: Object3D): ShapeParameters<ShapeType.BOX> | null {\n\tconst clone = object.clone();\n\tclone.quaternion.set(0, 0, 0, 1);\n\tclone.updateMatrixWorld();\n\n\tconst box = new Box3().setFromObject(clone);\n\n\tif (!isFinite(box.min.lengthSq())) return null;\n\n\tconst localPosition = box.translate(clone.position.negate()).getCenter(new Vector3());\n\n\treturn {\n\t\ttype: ShapeType.BOX,\n\t\tparams: {\n\t\t\tx: (box.max.x - box.min.x) / 2,\n\t\t\ty: (box.max.y - box.min.y) / 2,\n\t\t\tz: (box.max.z - box.min.z) / 2,\n\t\t},\n\t\toffset: localPosition.lengthSq()\n\t\t\t? new Vec3(localPosition.x, localPosition.y, localPosition.z)\n\t\t\t: undefined,\n\t};\n}\n\n/** Computes 3D convex hull as a CANNON.ConvexPolyhedron. */\nfunction getConvexPolyhedronParameters (object: Object3D): ShapeParameters<ShapeType.HULL> | null {\n\tconst geometry = getGeometry(object);\n\n\tif (!geometry) return null;\n\n\t// Perturb.\n\tconst eps = 1e-4;\n\tfor (let i = 0; i < geometry.attributes.position.count; i++) {\n\t\tgeometry.attributes.position.setXYZ(\n\t\t\ti,\n\t\t\tgeometry.attributes.position.getX(i) + (Math.random() - 0.5) * eps,\n\t\t\tgeometry.attributes.position.getY(i) + (Math.random() - 0.5) * eps,\n\t\t\tgeometry.attributes.position.getZ(i) + (Math.random() - 0.5) * eps,\n\t\t);\n\t}\n\n\t// Compute the 3D convex hull and collect convex hull vertices and faces.\n\tconst [ positions, indices ] = new ConvexHull()\n\t\t.setFromObject(new Mesh(geometry))\n\t\t.toJSON();\n\n\treturn {\n\t\ttype: ShapeType.HULL,\n\t\tparams: {\n\t\t\tvertices: new Float32Array(positions),\n\t\t\tfaces: indices,\n\t\t},\n\t};\n}\n\nfunction getCylinderParameters (\n\tgeometry: CylinderGeometry\n): ShapeParameters<ShapeType.CYLINDER> | null {\n\tconst params = geometry.parameters;\n\n\treturn {\n\t\ttype: ShapeType.CYLINDER,\n\t\tparams: {\n\t\t\tradiusTop: params.radiusTop,\n\t\t\tradiusBottom: params.radiusBottom,\n\t\t\theight: params.height,\n\t\t\tsegments: params.radialSegments,\n\t\t},\n\t\torientation: new CQuaternion()\n\t\t\t.setFromEuler(MathUtils.degToRad(-90), 0, 0, 'XYZ')\n\t\t\t.normalize(),\n\t}\n}\n\nfunction getBoundingCylinderParameters (\n\tobject: Object3D,\n\toptions: ShapeOptions\n): ShapeParameters<ShapeType.CYLINDER> | null {\n\tconst axes = ['x', 'y', 'z'];\n\tconst majorAxis = options.cylinderAxis || 'y';\n\tconst minorAxes = axes.splice(axes.indexOf(majorAxis), 1) && axes;\n\tconst box = new Box3().setFromObject(object);\n\n\tif (!isFinite(box.min.lengthSq())) return null;\n\n\t// Compute cylinder dimensions.\n\tconst height = box.max[majorAxis] - box.min[majorAxis];\n\tconst radius = 0.5 * Math.max(\n\t\tgetComponent(box.max, minorAxes[0]) - getComponent(box.min, minorAxes[0]),\n\t\tgetComponent(box.max, minorAxes[1]) - getComponent(box.min, minorAxes[1]),\n\t);\n\n\tconst eulerX = majorAxis === 'y' ? PI_2 : 0;\n\tconst eulerY = majorAxis === 'z' ? PI_2 : 0;\n\n\treturn {\n\t\ttype: ShapeType.CYLINDER,\n\t\tparams: {\n\t\t\tradiusTop: radius,\n\t\t\tradiusBottom: radius,\n\t\t\theight,\n\t\t\tsegments: 12,\n\t\t},\n\t\torientation: new CQuaternion()\n\t\t\t.setFromEuler(eulerX, eulerY, 0, 'XYZ')\n\t\t\t.normalize(),\n\t};\n}\n\nfunction getPlaneParameters (geometry: BufferGeometry): ShapeParameters<ShapeType.BOX> | null {\n\tgeometry.computeBoundingBox();\n\tconst box = geometry.boundingBox!;\n\n\treturn {\n\t\ttype: ShapeType.BOX,\n\t\tparams: {\n\t\t\tx: (box.max.x - box.min.x) / 2 || 0.1,\n\t\t\ty: (box.max.y - box.min.y) / 2 || 0.1,\n\t\t\tz: (box.max.z - box.min.z) / 2 || 0.1,\n\t\t},\n\t};\n}\n\nfunction getSphereParameters (geometry: SphereGeometry): ShapeParameters<ShapeType.SPHERE> | null {\n\treturn {\n\t\ttype: ShapeType.SPHERE,\n\t\tparams: { radius: geometry.parameters.radius },\n\t};\n}\n\nfunction getBoundingSphereParameters (\n\tobject: Object3D,\n\toptions: ShapeOptions\n): ShapeParameters<ShapeType.SPHERE> | null {\n\tif (options.sphereRadius) {\n\t\treturn {\n\t\t\ttype: ShapeType.SPHERE,\n\t\t\tparams: { radius: options.sphereRadius },\n\t\t};\n\t}\n\tconst geometry = getGeometry(object);\n\tif (!geometry) return null;\n\tgeometry.computeBoundingSphere();\n\n\treturn {\n\t\ttype: ShapeType.SPHERE,\n\t\tparams: { radius: geometry.boundingSphere!.radius },\n\t};\n}\n\nfunction getTrimeshParameters (geometry: BufferGeometry): ShapeParameters<ShapeType.MESH> | null {\n\tconst vertices = getVertices(geometry);\n\n\tif (!vertices.length) return null;\n\n\tconst indices = new Uint32Array(vertices.length);\n\tfor (let i = 0; i < vertices.length; i++) {\n\t\tindices[i] = i;\n\t}\n\n\treturn {\n\t\ttype: ShapeType.MESH,\n\t\tparams: {\n\t\t\tvertices,\n\t\t\tindices,\n\t\t},\n\t};\n}\n"],
  "mappings": "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",
  "names": ["ConvexHull", "Visible", "Deleted", "v1", "Vector3", "tolerance", "faces", "newFaces", "assigned", "VertexList", "unassigned", "vertices", "Object", "assign", "prototype", "toJSON", "srcIndices", "map", "f", "toArray", "uniqueSrcIndices", "Array", "from", "Set", "flat", "sort", "dstPositions", "i", "length", "push", "point", "x", "y", "z", "srcToDstIndexMap", "Map", "set", "dstIndices", "get", "setFromPoints", "points", "isArray", "console", "error", "makeEmpty", "l", "VertexNode", "compute", "setFromObject", "object", "updateMatrixWorld", "traverse", "node", "geometry", "undefined", "isGeometry", "toBufferGeometry", "BufferGeometry", "fromGeometry", "isBufferGeometry", "attribute", "attributes", "position", "count", "fromBufferAttribute", "applyMatrix4", "matrixWorld", "containsPoint", "face", "distanceToPoint", "intersectRay", "ray", "target", "tNear", "tFar", "Infinity", "vN", "origin", "vD", "normal", "dot", "direction", "t", "Math", "min", "max", "at", "intersectsRay", "addVertexToFace", "vertex", "outside", "append", "insertBefore", "removeVertexFromFace", "next", "remove", "removeAllVerticesFromFace", "start", "end", "removeSubList", "prev", "deleteFaceVertices", "absorbingFace", "faceVertices", "appendChain", "nextVertex", "distance", "resolveUnassignedPoints", "isEmpty", "first", "maxDistance", "maxFace", "mark", "computeExtremes", "minVertices", "maxVertices", "j", "copy", "getComponent", "setComponent", "Number", "EPSILON", "abs", "computeInitialHull", "line3", "plane", "closestPoint", "Line3", "Plane", "extremes", "v0", "v2", "v3", "index", "closestPointToPoint", "distanceToSquared", "setFromCoplanarPoints", "Face", "create", "getEdge", "setTwin", "reindexFaces", "activeFaces", "nextVertexToAdd", "eyeVertex", "eyeFace", "computeHorizon", "eyePoint", "crossEdge", "horizon", "edge", "twinEdge", "twin", "oppositeFace", "addAdjoiningFace", "horizonEdge", "tail", "head", "addNewFaces", "firstSideEdge", "previousSideEdge", "sideEdge", "addVertexToHull", "clear", "cleanup", "midpoint", "area", "constant", "a", "b", "c", "e0", "HalfEdge", "e1", "e2", "indices", "triangle", "Triangle", "getNormal", "getMidpoint", "getArea", "distanceTo", "lengthSquared", "last", "insertAfter", "_v1", "_v2", "_q1", "Quaternion", "getGeometry", "meshes", "getMeshes", "normalizeGeometry", "mesh", "geometries", "pop", "simplifyGeometry", "mergeBufferGeometries", "clone", "decompose", "scale", "vertexCount", "itemSize", "positionArray", "Float32Array", "positionOffset", "getX", "getY", "getZ", "setAttribute", "BufferAttribute", "getVertices", "o", "isMesh", "v", "component", "Error", "hashToIndex", "getIndex", "positions", "getAttribute", "nextIndex", "newIndices", "newPositions", "decimalShift", "log10", "shiftMultiplier", "pow", "hash", "positionAttribute", "normalized", "result", "setIndex", "PI_2", "PI", "ShapeType", "getShapeParameters", "options", "type", "BOX", "getBoundingBoxParameters", "CYLINDER", "getBoundingCylinderParameters", "SPHERE", "getBoundingSphereParameters", "HULL", "getConvexPolyhedronParameters", "MESH", "getTrimeshParameters", "getBoxParameters", "getCylinderParameters", "getPlaneParameters", "getSphereParameters", "warn", "threeToCannon", "shapeParameters", "params", "offset", "orientation", "shape", "createBox", "createCylinder", "createSphere", "createConvexPolyhedron", "createTrimesh", "Box", "Vec3", "radiusTop", "radiusBottom", "height", "segments", "Cylinder", "numSegments", "Sphere", "radius", "verticesArray", "ConvexPolyhedron", "Trimesh", "computeBoundingBox", "box", "boundingBox", "quaternion", "Box3", "isFinite", "lengthSq", "localPosition", "translate", "negate", "getCenter", "eps", "setXYZ", "random", "Mesh", "parameters", "radialSegments", "CQuaternion", "setFromEuler", "MathUtils", "degToRad", "normalize", "axes", "majorAxis", "cylinderAxis", "minorAxes", "splice", "indexOf", "eulerX", "eulerY", "sphereRadius", "computeBoundingSphere", "boundingSphere", "Uint32Array"]
}
